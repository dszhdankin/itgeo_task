## Решение программной части тестового задания

### Примечание
Из соображений простоты реализации в коде допускались "вольности" в виде публичных полей
классов, неполной проверки корректности входных данных и так далее. Для решения тестовых
алгоритмических задач не кажется разумным писать код соответствующий best software 
engineering techniques and practices.

### Прямоугольники
Решение основано на методе сканирующей прямой. Идём вдоль оси х, поддерживая
актуальную проекцию множества объединения прямоугольников на ось y. Каждый раз,
когда проекция изменяется обновляем результат. Алгоритмическая сложность 
наивной реализации квадратичная. Поддержание множества можно оптимизировать с помощью дерева
отрезков, эксплуатируя тот факт, что удаляемый из множества отрезок гарантированно 
был добавлен в него, что и было сделано. Также поддержание множества можно оптимизировать 
деревом поиска с любым методом балансировки, но из соображений простоты реализации было 
выбрано дерево отрезков.

### Монеты
Задача представляет собой немного модифицированный вариант стандартной 
задачи о рюкзаке. Приведено решение методом динамического программирования.
Если для задачи о рюкзаке dp[n][k] = max(dp[n][k-1], dp[n-weight[k]][k-1] +
cost[k]), здесь dp[n][k] = dp[n][k-1] + dp[n-weight[k]][k]. 
(k-я монета либо используется для размена, либо нет)